<?php
/**
 * This file is part of PhpCocktail. PhpCocktail is free software: you can redistribute it and/or modify it under the
 * 		terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3
 * 		of the License, or (at your option) any later version.
 * PhpCocktail is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * 		warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
 * 		more details. You should have received a copy of the GNU Lesser General Public License along with PhpCocktail.
 * 		If not, see <http://www.gnu.org/licenses/>.
 * @copyright Copyright 2013 t
 */
namespace Cocktail;

/**
 * Block is a simplified controller which has only one action, generate() and so a toString() method
 * Blocks may have their children, which can be hmvcrouted (see hmvccontroller).
 * You can find some sample blocks in Cocktail, like column container, etc.
 *
 * @author t
 * @package Cocktail\Block
 * @version 1.01
 */
abstract class Block extends \Config {

	/**
	 * @var string you can define this but will be guessed by classname, eg. Block/BlockSomething.html
	 */
	protected $_template;
	/**
	 * @var string define this to automatically apply a layout
	 */
	protected $_layout;
	/**
	 * @var \View object
	 */
	protected $_View;
	/**
	 *
	 * @var array[string]mixed data for the main view
	 */
	protected $_viewData = array();
	/**
	 * @var mixed
	 */
	protected $_content;
	/**
	 * Use this to eg. append '.html' to autogenerated template filenames
	 * @var string
	 */
	protected $_templateFnameSuffix = '.html';

	/**
	 * I return an instance. Remember I'm protected only so you overwrite and provide phpdoc
	 * @param string $template template name to be used
	 * @param array|string data or css ID if string
	 * @return static
	 */
	public static function get($template=null, $dataOrCssId=null) {
		$Object = new static();
		if (!is_null($template)) {
			$Object->_template = $template;
		}
		if (is_array($dataOrCssId)) {
			$Object->_viewData = $dataOrCssId;
		}
		elseif  (is_string($dataOrCssId)) {
			$Object->_viewData['cssId'] = $dataOrCssId;
		};
		return $Object;
	}

	/**
	 * I set one (or more) variable(s) for my View object. Setting these values may happen before _before() is invoked
	 * @param array|string $key
	 * @param mixed $value
	 * @return \Block
	 */
	public function setViewData($key, $value=null) {

		if (is_array($key) && (func_num_args() == 1)) {
			foreach ($key as $eachKey=>$eachValue) {
				$this->_viewData[$eachKey] = $eachValue;
			}
		}
		elseif (is_string($key) && !empty($key) && (func_num_args() == 2)) {
			$this->_viewData[$key] = $value;
		}
		return $this;
	}

	/**
	 * I return all viewdata or a field of it
	 * @param string|null $key
	 * @return array[string]mixed|mixed
	 */
	public function getViewData($key=null) {
		if (is_null($key) || ($key===true)) {
			$ret = $this->_viewData;
		}
		elseif (array_key_exists($key, $this->_viewData)) {
			$ret = $this->_viewData[$key];
		}
		else {
			$ret = null;
		}
		return $ret;
	}

	/**
	 * I generate and return the content. Note that it may not be a string, use toString if you need a string
	 * @param bool if true, I re-generate (content might have been generated before)
	 * @return mixed whatever set by sub method calls into $this->_content
	 */
	public function generate() {
		$this->_before();
		$this->_content = $this->_generate();
		$this->_after();
		return $this->_content;
	}

	/**
	 * I return generated content as a string (and call generate() if necessary)
	 * @return string
	 */
	public function toString() {
		if (empty($this->_content)) {
			$this->generate();
		}
		return \Util::toString($this->_content);
	}

	/**
	 * I create the View object
	 */
	protected function _before() {
		$this->_View = \View::get($this->_getTemplateFname($this->_template));
	}

	/**
	 * I apply layout, if set
	 */
	protected function _after() {
		if (!empty($this->_layout)) {
			$LayoutView = \View::get($this->_getTemplateFname($this->_layout), $this->_viewData)
					->set('layoutContent', $this->_content);
			$this->_content = $LayoutView;
			// @todo implement layout here
			die('@todo test me');
		}
	}

	/**
	 * I generate contents of this block. Override this as necessary. No need tolayout here, will be done in after()
	 * @return View the object I generated
	 */
	protected function _generate() {
		$this->_View->assign($this->_viewData);
		return $this->_View;
	}

	/**
	 * I return template filename , defaulting it by current classname, and prepending folder name, as necessary
	 * 	note the returned filename is relative to template root, which can vary, and its locating logic is in the View
	 * 	class.
	 * @param string input filename
	 * @return string template filename
	 */
	protected function _getTemplateFname($fname=null) {

		if (empty($fname)) {
			$namespace = '';
			$fname = get_class($this);
			if (($pos = strrpos($fname, '\\')) !== false) {
				$namespace = substr($fname, 0, $pos);
				$fname = substr($fname, $pos+1);
			}
			$fname.= $this->_templateFnameSuffix;
		}

		if (empty($fname)) {
			throw new \RuntimeException();
		}

		// if it's an absolute path, nothing to do.
		if ($fname[0] == '/');
		// if filename doesn't have folder name, try to prepend it
		elseif (strpos($fname, '/') === false) {
			$fnameX = array();
			$offset = 0;
			for ($i=1; $i<strlen($fname); $i++) {
				if ($fname[$i] === strtoupper($fname[$i])) {
					$fnameX[] = substr($fname, $offset, $i-$offset);
					$offset = $i;
				}
			}
			array_pop($fnameX);
			$fname = implode('/', array_merge($fnameX, array($fname)));
		}

		return $fname;
	}

}
